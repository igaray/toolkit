--------------------------------------------------------------------------------
ADT:Element

Types:

element_t: element type

Operations:
    new
    destroy
    set
    get

--------------------------------------------------------------------------------
ADT:List

Types:

node_t:     linked list node type
position_t: linked list position type
list_t:     linked list typed

Operations:

void create_list(list_t*);
void delete_list(list_t*);

position_t last(list_t);
position_t first(list_t);
position_t next(list_t, position_t);
position_t prev(list_t, position_t);
position_t find(list_t, element_t);
element_t getp(list_t, position_t);
element_t geti(list_t, int);
int is_empty(list_t);
int length(list_t);
void print(list_t, char *string, int *size);

void insertp(list_t, element_t, position_t);
void inserti(list_t, element_t, int);
void insert_first(list_t, element_t);
void insert_last(list_t, element_t);
void removep(list_t, position_t);
void removei(list_t, int);

Implementations:
    
    SIM: simply linked
    When a list is simply linked, each node in the list contains a pointer to the following node in the list.
    Traversal of the list is efficient only going forward
    
    DBL: doubly linked
    When a list is doubly linked, each node in the list contains a pointer to the following node and another pointer to the previous node, so that traversal of the list is efficient in both forwards and backwards.

    LIN: linear
    When a list is linear it has distinguishable starting and ending nodes.
    
    CIR: circular
    When a list is circular the last node points to the first node as its following node, making it a ring.

    DP: direct positioning
    With direct positiong the element pointed at is in the cell pointed at.

    IP: indirect positioning
    With indirect positioning the element pointed at is in the cell that the pointed cell points at.
    To solve some limit cases, such as accesing the first element, an empty node is included at the beginning of the list.

    NH: without head
    WH: with head
    A head is a special structure at the begnning of the list with additional information such as the length of the list and pointers to the first and last nodes.

--------------------------------------------------------------------------------
ADT:Stack

Operations:
    CrearPila
    Vacia
    Tope
    Apilar
    Desapilar

Implementations:
    - arreglos
    - listas enlazadas

From Meyer, OOSD
    ADT: Stacks

    Types:
        Stacks[G]
        
    Functions:
        put:    Stack[G] x G -> Stack[G]
        remove: Stack[G] -> Stack[G]
        item:   Stack[G] -> G
        empty:  Stack[G] -> Boolean
        new:    Stack[G]

    Axioms:
        For any x : G, s : Stack[G]
        1) item(put(s,x)) = x
        2) remove(put(s,x)) = s
        3) empty(new)
        4) not empty(put(s,x))
        
    Preconditions:
        remove(s : Stack[G]) requires not empty(s)
        item(s : Stack[G]) requires not empty(s)
    
--------------------------------------------------------------------------------
ADT:Linear Queue

Operations:
    CrearCola
    Vacia
    Frente
    InsertarEnCola
    RetirarDeCola

Implementaciones:
    - arreglos circulares
    - linear lista enlazada

--------------------------------------------------------------------------------
ADT: Tree

Operations:
    Crear
    Padre
    HijoExtremoIzquierdo
    HijoDerecho
    Etiqueta
    Raiz

Implementations:
    - ab (arboles binarios)
    - abb (arboles binarios de busqueda)
    - avl (arboles balanceados)
    - trie
    - red-black

--------------------------------------------------------------------------------
TDA:Conjunto

Operations:
    CrearConjunta
    Insertar
    Eliminar
    Miembro
    Union
    Interseccion
    Diferencia
    Minimo
    Maximo

--------------------------------------------------------------------------------
TDA:Diccionario

Operations:
    CrearDiccionario
    Insertar
    Eliminar
    Miembro

--------------------------------------------------------------------------------
TDA:Cola con prioridad

Operations:
    CrearColaConPrioridad
    Insertar
    EliminarMinimo

--------------------------------------------------------------------------------
TDA:Mapeo

Operations:
    CrearMapeo
    Asigna
    Calcula

--------------------------------------------------------------------------------
TDA:NodoTRIE

Operations:
    Crear
    Asigna
    Valor
    TomaNuevo

--------------------------------------------------------------------------------
TDA:Grafo

Operations:
    CrearGrafo
    PrimerVertice
    SiguienteVertice
    PrimerAdyacente
    SiguienteAdyacente
    Vertice
    RotuloArco
    RotuloVertice
    InsertarArco
    InsertarVertice
    EliminarArco
    EliminarVertice

Implementaciones: 32 tipos de grafos

    DG dirigido
    UG no dirigido

    CAR con arcos rotulados
    SAR sin arcos rotulados

    CVR con vertices rotulados
    SVR sin vertices rotulados

    CAP con arcos paralelos
    SAP sin arcos paralelos

    MA matriz de adyacencia
    LA listas de adyacencia
